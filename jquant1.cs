#if QUANT_1PASS_SUPPORTED
// jquant1.cs
//
// Based on libjpeg version 6b - 27-Mar-1998
// Copyright (C) 2007-2008 by the Authors
// Copyright (C) 1991-1996, Thomas G. Lane.
// For conditions of distribution and use, see the accompanying License.txt file.
//
// This file contains 1-pass color quantization (color mapping) routines.
// These routines provide mapping to a fixed color map using equally spaced
// color values. Optional Floyd-Steinberg or ordered dithering is available.

using System;
using System.Collections.Generic;
using System.Text;

namespace Free.Ports.LibJpeg
{
	public static partial class libjpeg
	{
		// The main purpose of 1-pass quantization is to provide a fast, if not very
		// high quality, colormapped output capability. A 2-pass quantizer usually
		// gives better visual quality; however, for quantized grayscale output this
		// quantizer is perfectly adequate. Dithering is highly recommended with this
		// quantizer, though you can turn it off if you really want to.
		//
		// In 1-pass quantization the colormap must be chosen in advance of seeing the
		// image. We use a map consisting of all combinations of Ncolors[i] color
		// values for the i'th component. The Ncolors[] values are chosen so that
		// their product, the total number of colors, is no more than that requested.
		// (In most cases, the product will be somewhat less.)
		//
		// Since the colormap is orthogonal, the representative value for each color
		// component can be determined without considering the other components;
		// then these indexes can be combined into a colormap index by a standard
		// N-dimensional-array-subscript calculation. Most of the arithmetic involved
		// can be precalculated and stored in the lookup table colorindex[].
		// colorindex[i][j] maps pixel value j in component i to the nearest
		// representative value (grid plane) for that component; this index is
		// multiplied by the array stride for component i, so that the
		// index of the colormap entry closest to a given pixel value is just
		//	sum( colorindex[component-number][pixel-component-value] )
		// Aside from being fast, this scheme allows for variable spacing between
		// representative values with no additional lookup cost.
		//
		// If gamma correction has been applied in color conversion, it might be wise
		// to adjust the color grid spacing so that the representative colors are
		// equidistant in linear space. At this writing, gamma correction is not
		// implemented by jdcolor, so nothing is done here.

		// Declarations for ordered dithering.
		//
		// We use a standard 16x16 ordered dither array. The basic concept of ordered
		// dithering is described in many references, for instance Dale Schumacher's
		// chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
		// In place of Schumacher's comparisons against a "threshold" value, we add a
		// "dither" value to the input pixel and then round the result to the nearest
		// output value. The dither value is equivalent to (0.5 - threshold) times
		// the distance between output values. For ordered dithering, we assume that
		// the output colors are equally spaced; if not, results will probably be
		// worse, since the dither may be too much or too little at a given point.

		const int ODITHER_SIZE=16;	// dimension of dither matrix
		// NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break
		const int ODITHER_CELLS=(ODITHER_SIZE*ODITHER_SIZE);	// # cells in matrix
		const int ODITHER_MASK=(ODITHER_SIZE-1);				// mask for wrapping around counters

		//typedef int ODITHER_MATRIX[ODITHER_SIZE, ODITHER_SIZE];
		//typedef int (*ODITHER_MATRIX_PTR)[ODITHER_SIZE];

		// Bayer's order-4 dither array. Generated by the code given in
		// Stephen Hawley's article "Ordered Dithering" in Graphics Gems I.
		// The values in this array must range from 0 to ODITHER_CELLS-1.
		static readonly byte[,] base_dither_matrix=new byte[ODITHER_SIZE, ODITHER_SIZE] {
			{   0,192, 48,240, 12,204, 60,252,  3,195, 51,243, 15,207, 63,255 },
			{ 128, 64,176,112,140, 76,188,124,131, 67,179,115,143, 79,191,127 },
			{  32,224, 16,208, 44,236, 28,220, 35,227, 19,211, 47,239, 31,223 },
			{ 160, 96,144, 80,172,108,156, 92,163, 99,147, 83,175,111,159, 95 },
			{   8,200, 56,248,  4,196, 52,244, 11,203, 59,251,  7,199, 55,247 },
			{ 136, 72,184,120,132, 68,180,116,139, 75,187,123,135, 71,183,119 },
			{  40,232, 24,216, 36,228, 20,212, 43,235, 27,219, 39,231, 23,215 },
			{ 168,104,152, 88,164,100,148, 84,171,107,155, 91,167,103,151, 87 },
			{   2,194, 50,242, 14,206, 62,254,  1,193, 49,241, 13,205, 61,253 },
			{ 130, 66,178,114,142, 78,190,126,129, 65,177,113,141, 77,189,125 },
			{  34,226, 18,210, 46,238, 30,222, 33,225, 17,209, 45,237, 29,221 },
			{ 162, 98,146, 82,174,110,158, 94,161, 97,145, 81,173,109,157, 93 },
			{  10,202, 58,250,  6,198, 54,246,  9,201, 57,249,  5,197, 53,245 },
			{ 138, 74,186,122,134, 70,182,118,137, 73,185,121,133, 69,181,117 },
			{  42,234, 26,218, 38,230, 22,214, 41,233, 25,217, 37,229, 21,213 },
			{ 170,106,154, 90,166,102,150, 86,169,105,153, 89,165,101,149, 85 }
		};

		// Declarations for Floyd-Steinberg dithering.
		//
		// Errors are accumulated into the array fserrors[], at a resolution of
		// 1/16th of a pixel count. The error at a given pixel is propagated
		// to its not-yet-processed neighbors using the standard F-S fractions,
		//		...		(here)	7/16
		//		3/16	5/16	1/16
		// We work left-to-right on even rows, right-to-left on odd rows.
		//
		// We can get away with a single array (holding one row's worth of errors)
		// by using it to store the current row's errors at pixel columns not yet
		// processed, but the next row's errors at columns already processed. We
		// need only a few extra variables to hold the errors immediately around the
		// current column. (If we are lucky, those variables are in registers, but
		// even if not, they're probably cheaper to access than array elements are.)
		//
		// The fserrors[] array is indexed [component#][position].
		// We provide (#columns + 2) entries per component; the extra entry at each
		// end saves us from special-casing the first and last pixels.
		//
		// Note: on a wide image, we might not have enough room in a PC's near data
		// segment to hold the error array; so it is allocated with alloc.

		// Private subobject
		const int MAX_Q_COMPS=4;		// max components I can handle

		class my_cquantizer1 : jpeg_color_quantizer
		{
			// Initially allocated colormap is saved here
			public byte[][] sv_colormap;	// The color map as a 2-D pixel array
			public int sv_actual;			// number of entries in use

			public byte[][] colorindex;	// Precomputed mapping for speed
			// colorindex[i][j] = index of color closest to pixel value j in component i,
			// premultiplied as described above. Since colormap indexes must fit into
			// bytes, the entries of this array will too.

			public int[] Ncolors=new int[MAX_Q_COMPS]; // # of values alloced to each component

			// Variables for ordered dithering
			public int row_index; // cur row's vertical index in dither matrix
			public int[][,] odither=new int[MAX_Q_COMPS][,]; // one dither array per component

			// Variables for Floyd-Steinberg dithering
			public int[][] fserrors=new int[MAX_Q_COMPS][]; // accumulated errors
			public bool on_odd_row; // flag to remember which row we are on
		}

		// Policy-making subroutines for create_colormap and create_colorindex.
		// These routines determine the colormap to be used. The rest of the module
		// only assumes that the colormap is orthogonal.
		//
		//	*	select_ncolors decides how to divvy up the available colors
		//		among the components.
		//	*	output_value defines the set of representative values for a component.
		//	*	largest_input_value defines the mapping from input values to
		//		representative values for a component.
		// Note that the latter two routines may impose different policies for
		// different components, though this is not currently done.
		static readonly int[] RGB_order=new int[3] { RGB_GREEN, RGB_RED, RGB_BLUE };

		// Determine allocation of desired colors to components,
		// and fill in Ncolors[] array to indicate choice.
		// Return value is total number of colors (product of Ncolors[] values).
		static int select_ncolors(jpeg_decompress cinfo, int[] Ncolors)
		{
			int nc=cinfo.out_color_components; // number of color components
			int max_colors=cinfo.desired_number_of_colors;
			int temp;

			// We can allocate at least the nc'th root of max_colors per component.
			// Compute floor(nc'th root of max_colors).
			int iroot=1;
			do
			{
				iroot++;
				temp=iroot;		// set temp = iroot ** nc
				for(int i=1; i<nc; i++) temp*=iroot;
			} while(temp<=(int)max_colors); // repeat till iroot exceeds root
			iroot--;			// now iroot = floor(root)

			// Must have at least 2 color values per component
			if(iroot<2) ERREXIT1(cinfo, J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS, (int)temp);

			// Initialize to iroot color values for each component
			int total_colors=1;
			for(int i=0; i<nc; i++)
			{
				Ncolors[i]=iroot;
				total_colors*=iroot;
			}

			// We may be able to increment the count for one or more components without
			// exceeding max_colors, though we know not all can be incremented.
			// Sometimes, the first component can be incremented more than once!
			// (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
			// In RGB colorspace, try to increment G first, then R, then B.
			bool changed;
			do
			{
				changed=false;
				for(int i=0; i<nc; i++)
				{
					int j=(cinfo.out_color_space==J_COLOR_SPACE.JCS_RGB?RGB_order[i]:i);
					// calculate new total_colors if Ncolors[j] is incremented
					temp=total_colors/Ncolors[j];
					temp*=Ncolors[j]+1;	// done in int arith to avoid oflo
					if(temp>(int)max_colors) break; // won't fit, done with this pass

					Ncolors[j]++; // OK, apply the increment
					total_colors=(int)temp;
					changed=true;
				}
			} while(changed);

			return total_colors;
		}

		// Return j'th output value, where j will range from 0 to maxj
		// The output values must fall in 0..MAXJSAMPLE in increasing order
		static int output_value(jpeg_decompress cinfo, int ci, int j, int maxj)
		{
			// We always provide values 0 and MAXJSAMPLE for each component;
			// any additional values are equally spaced between these limits.
			// (Forcing the upper and lower values to the limits ensures that
			// dithering can't produce a color outside the selected gamut.)
			return (int)(((int)j*MAXJSAMPLE+maxj/2)/maxj);
		}

		// Return largest input value that should map to j'th output value
		// Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE
		static int largest_input_value(jpeg_decompress cinfo, int ci, int j, int maxj)
		{
			// Breakpoints are halfway between values returned by output_value
			return (int)(((int)(2*j+1)*MAXJSAMPLE+maxj)/(2*maxj));
		}

		// Create the colormap.
		static void create_colormap(jpeg_decompress cinfo)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;

			// Select number of colors for each component
			int total_colors=select_ncolors(cinfo, cquantize.Ncolors); // Number of distinct output colors

			// Report selected color counts
			if(cinfo.out_color_components==3) TRACEMS4(cinfo, 1, J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS, total_colors, cquantize.Ncolors[0], cquantize.Ncolors[1], cquantize.Ncolors[2]);
			else TRACEMS1(cinfo, 1, J_MESSAGE_CODE.JTRC_QUANT_NCOLORS, total_colors);

			// Allocate and fill in the colormap.
			// The colors are ordered in the map in standard row-major order,
			// i.e. rightmost (highest-indexed) color changes most rapidly.
			byte[][] colormap=alloc_sarray(cinfo, (uint)total_colors, (uint)cinfo.out_color_components);

			// blksize is number of adjacent repeated entries for a component
			// blkdist is distance between groups of identical entries for a component
			int blkdist=total_colors;

			for(int i=0; i<cinfo.out_color_components; i++)
			{
				// fill in colormap entries for i'th color component
				int nci=cquantize.Ncolors[i]; // # of distinct values for this color
				int blksize=blkdist/nci;
				for(int j=0; j<nci; j++)
				{
					// Compute j'th output value (out of nci) for component
					int val=output_value(cinfo, i, j, nci-1);
					// Fill in all colormap entries that have this value of this component
					for(int ptr=j*blksize; ptr<total_colors; ptr+=blkdist)
					{
						// fill in blksize entries beginning at ptr
						for(int k=0; k<blksize; k++) colormap[i][ptr+k]=(byte)val;
					}
				}
				blkdist=blksize; // blksize of this color is blkdist of next
			}

			// Save the colormap in private storage,
			// where it will survive color quantization mode changes.
			cquantize.sv_colormap=colormap;
			cquantize.sv_actual=total_colors;
		}

		// Create the color index table.
		static void create_colorindex(jpeg_decompress cinfo)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;

			cquantize.colorindex=alloc_sarray(cinfo, (uint)(MAXJSAMPLE+1), (uint)cinfo.out_color_components);

			// blksize is number of adjacent repeated entries for a component
			int blksize=cquantize.sv_actual;

			for(int i=0; i<cinfo.out_color_components; i++)
			{
				// fill in colorindex entries for i'th color component
				int nci=cquantize.Ncolors[i]; // # of distinct values for this color
				blksize=blksize/nci;

				// in loop, val = index of current output value,
				// and k = largest j that maps to current val
				byte[] indexptr=cquantize.colorindex[i];
				int val=0;
				int k=largest_input_value(cinfo, i, 0, nci-1);
				for(int j=0; j<=MAXJSAMPLE; j++)
				{
					while(j>k) k=largest_input_value(cinfo, i, ++val, nci-1); // advance val if past boundary

					// premultiply so that no multiplication needed in main processing
					indexptr[j]=(byte)(val*blksize);
				}
			}
		}

		// Create an ordered-dither array for a component having ncolors
		// distinct output values.
		static int[,] make_odither_array(jpeg_decompress cinfo, int ncolors)
		{
			int[,] odither=null;

			try
			{
				odither=new int[ODITHER_SIZE, ODITHER_SIZE];
			}
			catch
			{
				ERREXIT1(cinfo, J_MESSAGE_CODE.JERR_OUT_OF_MEMORY, 4);
			}

			// The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
			// Hence the dither value for the matrix cell with fill order f
			// (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
			// On 16-bit-int machine, be careful to avoid overflow.
			int den=2*ODITHER_CELLS*((int)(ncolors-1));
			for(int j=0; j<ODITHER_SIZE; j++)
			{
				for(int k=0; k<ODITHER_SIZE; k++)
				{
					int num=((int)(ODITHER_CELLS-1-2*((int)base_dither_matrix[j, k])))*MAXJSAMPLE;
					// Ensure round towards zero despite C's lack of consistency
					// about rounding negative values in integer division...
					odither[j, k]=(int)(num<0?-((-num)/den):num/den);
				}
			}
			return odither;
		}

		// Create the ordered-dither tables.
		// Components having the same number of representative colors may 
		// share a dither table.
		static void create_odither_tables(jpeg_decompress cinfo)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;

			for(int i=0; i<cinfo.out_color_components; i++)
			{
				int nci=cquantize.Ncolors[i];	// # of distinct values for this color
				int[,] odither=null;				// search for matching prior component
				for(int j=0; j<i; j++)
				{
					if(nci==cquantize.Ncolors[j])
					{
						odither=cquantize.odither[j];
						break;
					}
				}
				if(odither==null) odither=make_odither_array(cinfo, nci); // need a new table?
				cquantize.odither[i]=odither;
			}
		}

		// Map some rows of pixels to the output colormapped representation.
		// General case, no dithering
		static void color_quantize(jpeg_decompress cinfo, byte[][] input_buf, uint input_row, byte[][] output_buf, uint output_row, int num_rows)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;
			byte[][] colorindex=cquantize.colorindex;
			uint width=cinfo.output_width;
			int nc=cinfo.out_color_components;

			for(int row=0; row<num_rows; row++)
			{
				byte[] ptrin=input_buf[input_row+row];
				byte[] ptrout=output_buf[output_row+row];
				uint iind=0, oind=0;
				for(uint col=width; col>0; col--)
				{
					int pixcode=0;
					for(int ci=0; ci<nc; ci++)
					{
						pixcode+=colorindex[ci][ptrin[iind++]];
					}
					ptrout[oind++]=(byte)pixcode;
				}
			}
		}

		// Fast path for out_color_components==3, no dithering
		static void color_quantize3(jpeg_decompress cinfo, byte[][] input_buf, uint input_row, byte[][] output_buf, uint output_row, int num_rows)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;
			byte[] colorindex0=cquantize.colorindex[0];
			byte[] colorindex1=cquantize.colorindex[1];
			byte[] colorindex2=cquantize.colorindex[2];
			uint width=cinfo.output_width;

			for(int row=0; row<num_rows; row++)
			{
				byte[] ptrin=input_buf[input_row+row];
				byte[] ptrout=output_buf[output_row+row];
				uint iind=0, oind=0;
				for(uint col=width; col>0; col--)
				{
					int pixcode=colorindex0[ptrin[iind++]];
					pixcode+=colorindex1[ptrin[iind++]];
					pixcode+=colorindex2[ptrin[iind++]];
					ptrout[oind++]=(byte)pixcode;
				}
			}
		}

		// General case, with ordered dithering
		static void quantize_ord_dither(jpeg_decompress cinfo, byte[][] input_buf, uint input_row, byte[][] output_buf, uint output_row, int num_rows)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;
			int row_index;	// current indexes into dither matrix
			int nc=cinfo.out_color_components;
			uint width=cinfo.output_width;

			for(int row=0; row<num_rows; row++)
			{
				// Initialize output values to 0 so can process components separately
				for(int i=0; i<width; i++) output_buf[output_row+row][i]=0;
				row_index=cquantize.row_index;

				for(int ci=0; ci<nc; ci++)
				{
					byte[] input_ptr=input_buf[input_row+row];
					int iind=ci;
					byte[] output_ptr=output_buf[output_row+row];
					uint oind=0;
					byte[] colorindex_ci=cquantize.colorindex[ci];
					int[,] dither=cquantize.odither[ci]; // points to active row of dither matrix
					int col_index=0;

					for(uint col=width; col>0; col--)
					{
						// Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
						// select output value, accumulate into output code for this pixel.
						// Range-limiting need not be done explicitly, as we have extended
						// the colorindex table to produce the right answers for out-of-range
						// inputs. The maximum dither is +- MAXJSAMPLE; this sets the
						// required amount of padding.
						int tmp=input_ptr[iind]+dither[row_index, col_index];
						output_ptr[oind]+=colorindex_ci[(tmp>=MAXJSAMPLE?MAXJSAMPLE:(tmp<0?0:tmp))];
						iind+=nc;
						oind++;
						col_index=(col_index+1)&ODITHER_MASK;
					}
				}

				// Advance row index for next row
				row_index=(row_index+1)&ODITHER_MASK;
				cquantize.row_index=row_index;
			}
		}

		// Fast path for out_color_components==3, with ordered dithering
		static void quantize3_ord_dither(jpeg_decompress cinfo, byte[][] input_buf, uint input_row, byte[][] output_buf, uint output_row, int num_rows)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;
			byte[] colorindex0=cquantize.colorindex[0];
			byte[] colorindex1=cquantize.colorindex[1];
			byte[] colorindex2=cquantize.colorindex[2];
			uint width=cinfo.output_width;

			for(int row=0; row<num_rows; row++)
			{
				int row_index=cquantize.row_index;
				byte[] input_ptr=input_buf[input_row+row];
				byte[] output_ptr=output_buf[output_row+row];
				uint iind=0, oind=0;
				int[,] dither0=cquantize.odither[0]; // points to active row of dither matrix
				int[,] dither1=cquantize.odither[1];
				int[,] dither2=cquantize.odither[2];
				int col_index=0;

				for(uint col=width; col>0; col--)
				{
					int tmp=input_ptr[iind++]+dither0[row_index, col_index];
					int pixcode=colorindex0[(tmp>=MAXJSAMPLE?MAXJSAMPLE:(tmp<0?0:tmp))];

					tmp=input_ptr[iind++]+dither1[row_index, col_index];
					pixcode+=colorindex1[(tmp>=MAXJSAMPLE?MAXJSAMPLE:(tmp<0?0:tmp))];

					tmp=input_ptr[iind++]+dither2[row_index, col_index];
					pixcode+=colorindex2[(tmp>=MAXJSAMPLE?MAXJSAMPLE:(tmp<0?0:tmp))];

					output_ptr[oind++]=(byte)pixcode;
					col_index=(col_index+1)&ODITHER_MASK;
				}
				row_index=(row_index+1)&ODITHER_MASK;
				cquantize.row_index=row_index;
			}
		}

		// General case, with Floyd-Steinberg dithering
		static void quantize_fs_dither(jpeg_decompress cinfo, byte[][] input_buf, uint input_row, byte[][] output_buf, uint output_row, int num_rows)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;
			int[] errorptr;	// => fserrors[] at column before current
			int errorptr_ind;
			int pixcode;
			int nc=cinfo.out_color_components;
			int dir;			// 1 for left-to-right, -1 for right-to-left
			int dirnc;			// dir * nc
			uint width=cinfo.output_width;

			for(int row=0; row<num_rows; row++)
			{
				// Initialize output values to 0 so can process components separately
				for(int i=0; i<width; i++) output_buf[output_row+row][i]=0;

				for(int ci=0; ci<nc; ci++)
				{
					byte[] input_ptr=input_buf[input_row+row];
					int iind=ci;
					byte[] output_ptr=output_buf[output_row+row];
					int oind=0;
					if(cquantize.on_odd_row)
					{
						// work right to left in this row
						iind+=(int)(width-1)*nc; // so point to rightmost pixel
						oind+=(int)width-1;
						dir=-1;
						dirnc=-nc;
						errorptr=cquantize.fserrors[ci];
						errorptr_ind=(int)(width+1); // => entry after last column
					}
					else
					{
						// work left to right in this row
						dir=1;
						dirnc=nc;
						errorptr=cquantize.fserrors[ci]; // => entry before first column
						errorptr_ind=0;
					}
					byte[] colorindex_ci=cquantize.colorindex[ci];
					byte[] colormap_ci=cquantize.sv_colormap[ci];

					// Preset error values: no error propagated to first pixel from left
					int cur=0;

					// and no error propagated to row below yet
					int belowerr=0, bpreverr=0;

					for(uint col=width; col>0; col--)
					{
						// cur holds the error propagated from the previous pixel on the
						// current line. Add the error propagated from the previous line
						// to form the complete error correction term for this pixel, and
						// round the error term (which is expressed * 16) to an integer.
						// Right shift rounds towards minus infinity, so adding 8 is correct
						// for either sign of the error value.
						// Note: errorptr points to *previous* column's array entry.
						cur=(cur+errorptr[errorptr_ind+dir]+8)>>4;

						// Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
						// The maximum error is +- MAXJSAMPLE; this sets the required size
						// of the range_limit array.
						cur+=input_ptr[iind];
						cur=(cur>=MAXJSAMPLE?MAXJSAMPLE:(cur<0?0:cur));

						// Select output value, accumulate into output code for this pixel
						pixcode=colorindex_ci[cur];
						output_ptr[oind]+=(byte)pixcode;

						// Compute actual representation error at this pixel
						// Note: we can do this even though we don't have the final
						// pixel code, because the colormap is orthogonal.
						cur-=colormap_ci[pixcode];

						// Compute error fractions to be propagated to adjacent pixels.
						// Add these into the running sums, and simultaneously shift the
						// next-line error sums left by 1 column.
						int bnexterr=cur;
						int delta=cur*2;
						cur+=delta;		// form error * 3
						errorptr[errorptr_ind]=bpreverr+cur;
						cur+=delta;		// form error * 5
						bpreverr=belowerr+cur;
						belowerr=bnexterr;
						cur+=delta;		// form error * 7

						// At this point cur contains the 7/16 error value to be propagated
						// to the next pixel on the current line, and all the errors for the
						// next line have been shifted over. We are therefore ready to move on.
						iind+=dirnc;	// advance input ptr to next column
						oind+=dir;	// advance output ptr to next column
						errorptr_ind+=dir;		// advance errorptr to current column
					}
					// Post-loop cleanup: we must unload the final error value into the
					// final fserrors[] entry. Note we need not unload belowerr because
					// it is for the dummy column before or after the actual array.
					errorptr[errorptr_ind]=bpreverr; // unload prev err into array
				}
				cquantize.on_odd_row=(cquantize.on_odd_row?false:true);
			}
		}

		// Allocate workspace for Floyd-Steinberg errors.
		static void alloc_fs_workspace(jpeg_decompress cinfo)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;

			try
			{
				uint arraysize=cinfo.output_width+2;
				for(int i=0; i<cinfo.out_color_components; i++) cquantize.fserrors[i]=new int[arraysize];
			}
			catch
			{
				ERREXIT1(cinfo, J_MESSAGE_CODE.JERR_OUT_OF_MEMORY, 4);
			}
		}

		// Initialize for one-pass color quantization.
		static void start_pass_1_quant(jpeg_decompress cinfo, bool is_pre_scan)
		{
			my_cquantizer1 cquantize=(my_cquantizer1)cinfo.cquantize;

			// Install my colormap.
			cinfo.colormap=cquantize.sv_colormap;
			cinfo.actual_number_of_colors=cquantize.sv_actual;

			// Initialize for desired dithering mode.
			switch(cinfo.dither_mode)
			{
				case J_DITHER_MODE.JDITHER_NONE:
					if(cinfo.out_color_components==3) cquantize.color_quantize=color_quantize3;
					else cquantize.color_quantize=color_quantize;
					break;
				case J_DITHER_MODE.JDITHER_ORDERED:
					if(cinfo.out_color_components==3) cquantize.color_quantize=quantize3_ord_dither;
					else cquantize.color_quantize=quantize_ord_dither;
					cquantize.row_index=0;	// initialize state for ordered dither
					// Create ordered-dither tables if we didn't already.
					if(cquantize.odither[0]==null) create_odither_tables(cinfo);
					break;
				case J_DITHER_MODE.JDITHER_FS:
					cquantize.color_quantize=quantize_fs_dither;
					cquantize.on_odd_row=false; // initialize state for F-S dither

					// Allocate Floyd-Steinberg workspace if didn't already.
					if(cquantize.fserrors[0]==null) alloc_fs_workspace(cinfo);

					// Initialize the propagated errors to zero.
					uint arraysize=cinfo.output_width+2;
					for(int i=0; i<cinfo.out_color_components; i++)
						for(int j=0; j<arraysize; j++) cquantize.fserrors[i][j]=0;
					break;
				default:
					ERREXIT(cinfo, J_MESSAGE_CODE.JERR_NOT_COMPILED);
					break;
			}
		}

		// Finish up at the end of the pass.
		static void finish_pass_1_quant(jpeg_decompress cinfo)
		{
			// no work in 1-pass case
		}

		// Switch to a new external colormap between output passes.
		// Shouldn't get to this module!
		static void new_color_map_1_quant(jpeg_decompress cinfo)
		{
			ERREXIT(cinfo, J_MESSAGE_CODE.JERR_MODE_CHANGE);
		}

		// Module initialization routine for 1-pass color quantization.
		public static void jinit_1pass_quantizer(jpeg_decompress cinfo)
		{
			my_cquantizer1 cquantize=null;

			try
			{
				cquantize=new my_cquantizer1();
			}
			catch
			{
				ERREXIT1(cinfo, J_MESSAGE_CODE.JERR_OUT_OF_MEMORY, 4);
			}
			cinfo.cquantize=cquantize;
			cquantize.start_pass=start_pass_1_quant;
			cquantize.finish_pass=finish_pass_1_quant;
			cquantize.new_color_map=new_color_map_1_quant;
			cquantize.fserrors[0]=null; // Flag FS workspace not allocated
			cquantize.odither[0]=null;	// Also flag odither arrays not allocated

			// Make sure my internal arrays won't overflow
			if(cinfo.out_color_components>MAX_Q_COMPS) ERREXIT1(cinfo, J_MESSAGE_CODE.JERR_QUANT_COMPONENTS, MAX_Q_COMPS);

			// Make sure colormap indexes can be represented by bytes
			if(cinfo.desired_number_of_colors>(MAXJSAMPLE+1)) ERREXIT1(cinfo, J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);

			// Create the colormap and color index table.
			create_colormap(cinfo);
			create_colorindex(cinfo);

			// Allocate Floyd-Steinberg workspace now if requested.
			// We do this now since it is storage and may effect the memory
			// manager's space calculations. If the user changes to FS dither
			// mode in a later pass, we will allocate the space then, and will
			// possibly overrun the max_memory_to_use setting.
			if(cinfo.dither_mode==J_DITHER_MODE.JDITHER_FS) alloc_fs_workspace(cinfo);
		}
	}
}
#endif